import socket, argparse, ipaddress
# 彩色输出
from termcolor import colored
from loguru import logger
from queue import Queue
from concurrent.futures import ThreadPoolExecutor
# 进度条库
from tqdm import tqdm

# 用于存放目标地址
targets = []
# 存在漏洞的banner版本
vulnerable_versions = [
    'SSH-2.0-OpenSSH_8.5p1',
    'SSH-2.0-OpenSSH_8.6p1',
    'SSH-2.0-OpenSSH_8.7p1',
    'SSH-2.0-OpenSSH_8.8p1',
    'SSH-2.0-OpenSSH_8.9p1',
    'SSH-2.0-OpenSSH_9.0p1',
    'SSH-2.0-OpenSSH_9.1p1',
    'SSH-2.0-OpenSSH_9.2p1',
    'SSH-2.0-OpenSSH_9.3p1',
    'SSH-2.0-OpenSSH_9.4p1',
    'SSH-2.0-OpenSSH_9.5p1',
    'SSH-2.0-OpenSSH_9.6p1',
    'SSH-2.0-OpenSSH_9.7p1'
    ]

# 排除的版本
excluded_versions = [
    'SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10',
    'SSH-2.0-OpenSSH_9.3p1 Ubuntu-3ubuntu3.6',
    'SSH-2.0-OpenSSH_9.6p1 Ubuntu-3ubuntu13.3',
    'SSH-2.0-OpenSSH_9.3p1 Ubuntu-1ubuntu3.6',
    'SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u3',
    'SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u3',
    'SSH-2.0-OpenSSH_9.7p1 Debian-7'
    ]


# 检查端口是否开放
def Func_isPortOpen(target, port=22):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    try:
        sock.connect((target, port))
        sock.close()
        return True
    except (socket.timeout, socket.error):
        return False


# 获取SSH banner
def Func_getSshBanner(target, port=22):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    try:
        sock.connect((target, port))
        banner = sock.recv(1024).decode('utf-8').strip()
        sock.close()
        return banner
    except (socket.timeout, socket.error):
        return None


# 读取文件,按行读取
def Func_readFile(file_path):
    lines = []
    with open(file_path, 'r') as file:
        for line in file:
            stripped_line = line.strip()
            if stripped_line:
                lines.append(stripped_line)

    return lines


# 检查地址格式
def Func_checkAddress(address):
    targets = []

    try:
        # 检查 CIDR 格式
        if '/' in address:
            network = ipaddress.ip_network(address, strict=False)  # 使用 ipaddress 模块处理 CIDR
            for addr in network.hosts():
                targets.append(str(addr))

        # 检查范围格式
        elif '-' in address:
            start_ip, end = address.split('-')
            start = int(start_ip.split('.')[-1])
            end = int(end)
            if not (0 <= start <= 255 and 0 <= end <= 255 and start <= end):
                raise ValueError("Invalid range")
            base_ip = start_ip[:start_ip.rfind('.')+1]
            for i in range(start, end + 1):
                targets.append(f'{base_ip}{i}')

        # 检查单个 IP 格式
        else:
            socket.inet_aton(address)  # 验证 IP 地址
            targets.append(address)

    except (socket.error, ValueError, ipaddress.AddressValueError) as e:
        logger.error(f'Invalid IP Address: {e} --> {address}')
        return []  # 出错时返回空列表

    return targets


# 检查漏洞
def Func_checkVulnerability(ip, port, result_queue, progress):
    if not Func_isPortOpen(ip, port):
        result_queue.put((ip, port, 'closed', "Port closed"))
        
    else:
        banner = Func_getSshBanner(ip, port)
        if "SSH-2.0-OpenSSH" not in banner:
            result_queue.put((ip, port, 'failed', f"Failed to retrieve SSH banner: {banner}"))

        else:
            if any(version in banner for version in vulnerable_versions) and banner not in excluded_versions:
                result_queue.put((ip, port, 'vulnerable', f"(running {banner})"))
            else:
                result_queue.put((ip, port, 'not vulnerable', f"(running {banner})"))
                
    progress.update(1)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='SSH Scanner')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-t', '--target', help='Target IP')
    group.add_argument('-f', '--file', help='Input File')
    parser.add_argument('-p', '--port', help='Target Port', default=22)
    parser.add_argument('-T', '--threads', help='Number of threads', default=100, type=int)
    # 无漏洞是否显示
    parser.add_argument('--show-not-vulnerable', help='Show not vulnerable hosts', action='store_true')
    args = parser.parse_args()
    
    if args.target:
        targets = Func_checkAddress(args.target)

    if args.file:
        lines = Func_readFile(args.file)
        for line in lines:
            targets += Func_checkAddress(line)
            
    queue = Queue()
    total_targets = len(targets)
    progress = tqdm(total=total_targets, desc="Scanning", unit="target")
    max_workers = args.threads
    
    not_vulnerable  = []
    vulnerable = []
    closed_ports = 0
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = [executor.submit(Func_checkVulnerability, target, int(args.port), queue, progress) for target in targets]
        
        while any(future.running() for future in futures):
            while not queue.empty():
                ip, port, status, message = queue.get()
                if status == 'vulnerable':
                    vulnerable.append((ip, port, message))
                elif status == 'not vulnerable':
                    not_vulnerable.append((ip, port, message))
                elif status == 'closed':
                    closed_ports += 1
                    not_vulnerable.append((ip, port, message))
                else:
                    not_vulnerable.append((ip, port, message))

    progress.close()
    
    print(colored(f'\nVulnerable hosts ({len(vulnerable)}):', 'red'))
    for ip, port, message in vulnerable:
        print(colored(f'{ip}:{port} - Vulnerable {message}', 'red'))
    
    if args.show_not_vulnerable:
        print(colored(f'\nNot vulnerable hosts ({len(not_vulnerable)}):', 'green'))
        for ip, port, message in not_vulnerable:
            print(colored(f'{ip}:{port} - Not Vulnerable {message}', 'green'))
    
    res = f'totle: {total_targets}, vulnerable: {len(vulnerable)}, not vulnerable: {len(not_vulnerable)}, closed ports: {closed_ports}'
    print(colored(res, 'yellow'))
    print(colored(f'\nScan completed', 'blue'))
